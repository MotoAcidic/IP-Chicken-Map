<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Diagram with Chicken and Clippy</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    /* Make the body fill the screen */
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Container for the network and the images */
    #container {
      width: 100vw; /* Full width of the screen */
      height: 100vh; /* Full height of the screen */
      position: relative; /* Container for the map and images */
      overflow: hidden;
      border: 1px solid #ccc; /* Optional border to visualize the container */
    }

    /* Network should fill the container */
    #network {
      width: 100%; /* Full width of the container */
      height: 100%; /* Full height of the container */
      position: absolute;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Network Map -->
    <div id="network"></div>
  </div>

  <script>
    let network;
    let chickenNodeId = 'chicken';
    let clippyNodeId = 'clippy';
    let targetPositionChicken = { x: 0, y: 0 };
    let targetPositionClippy = { x: 0, y: 0 };
    const screenPadding = 50; // Padding to prevent off-screen dragging
    let nodes = [];
    let edges = [];
    let chickenSpeed = 5; // Default chicken speed
    let clippySpeed = 5; // Default clippy speed
    let chickenVelocity = { x: 0, y: 0 }; // Chicken velocity
    let clippyVelocity = { x: 0, y: 0 }; // Clippy velocity
    let isDraggingChicken = false;
    let isDraggingClippy = false;
    let lastMousePosition = { x: 0, y: 0 };

    async function getNetworkData() {
      const response = await fetch('/scan'); // Ensure your API is providing data
      return await response.json();
    }

    function inferConnections(devices) {
      const edges = [];
      for (let i = 0; i < devices.length - 1; i++) {
        const currentIp = devices[i].ip.split('.').map(Number);
        const nextIp = devices[i + 1].ip.split('.').map(Number);

        if (currentIp.slice(0, 3).join('.') === nextIp.slice(0, 3).join('.') && currentIp[3] + 1 === nextIp[3]) {
          edges.push({ from: i, to: i + 1 });
        }
      }
      return edges;
    }

    function drawNetwork(devices) {
      const container = document.getElementById('network');
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;

      nodes = devices.map((device, index) => ({
        id: index,
        label: `${device.name || 'Unknown'} (${device.ip})`,
        x: Math.random() * containerWidth - containerWidth / 2, // Random initial position
        y: Math.random() * containerHeight - containerHeight / 2 // Random initial position
      }));

      // Add the chicken as a node
      nodes.push({
        id: chickenNodeId,
        shape: 'image',
        image: 'chicken.png',
        size: 50,
        x: 0,
        y: 0
      });

      // Add the clippy as a node
      nodes.push({
        id: clippyNodeId,
        shape: 'image',
        image: 'clippy.jpg',
        size: 50,
        x: 0,
        y: 0
      });

      edges = inferConnections(devices);

      const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

      const options = {
        physics: {
          enabled: true,  // Enable physics to allow nodes to push each other around
          stabilization: { iterations: 150 } // More iterations to stabilize the network
        },
        interaction: {
          dragNodes: true,  // Allow dragging of nodes
          zoomView: true,   // Allow zooming
          dragView: true,   // Allow dragging of the view
        },
        layout: {
          improvedLayout: true,
        }
      };

      network = new vis.Network(container, data, options);

      // Set min and max zoom levels to allow zooming out
      network.on("zoom", function (params) {
        if (params.scale > 1.5) {
          network.moveTo({ scale: 1.5 }); // Max zoom in
        } else if (params.scale < 0.3) { // Allow more zoom out
          network.moveTo({ scale: 0.3 });
        }
      });

      // Add event listeners for dragging the chicken and clippy
      network.on("dragStart", function (params) {
        if (params.nodes.includes(chickenNodeId)) {
          isDraggingChicken = true;
          lastMousePosition = { x: params.event.center.x, y: params.event.center.y };
        } else if (params.nodes.includes(clippyNodeId)) {
          isDraggingClippy = true;
          lastMousePosition = { x: params.event.center.x, y: params.event.center.y };
        }
      });

      network.on("dragging", function (params) {
        if (isDraggingChicken) {
          const currentMousePosition = { x: params.event.center.x, y: params.event.center.y };
          chickenVelocity.x = currentMousePosition.x - lastMousePosition.x;
          chickenVelocity.y = currentMousePosition.y - lastMousePosition.y;
          lastMousePosition = currentMousePosition;
        } else if (isDraggingClippy) {
          const currentMousePosition = { x: params.event.center.x, y: params.event.center.y };
          clippyVelocity.x = currentMousePosition.x - lastMousePosition.x;
          clippyVelocity.y = currentMousePosition.y - lastMousePosition.y;
          lastMousePosition = currentMousePosition;
        }
      });

      network.on("dragEnd", function (params) {
        if (isDraggingChicken) {
          isDraggingChicken = false;
        } else if (isDraggingClippy) {
          isDraggingClippy = false;
        }
      });
    }

    function setRandomTargetPosition() {
      const container = document.getElementById('container');
      const containerWidth = container.offsetWidth - screenPadding;
      const containerHeight = container.offsetHeight - screenPadding;

      targetPositionChicken.x = Math.random() * containerWidth - containerWidth / 2;
      targetPositionChicken.y = Math.random() * containerHeight - containerHeight / 2;

      targetPositionClippy.x = Math.random() * containerWidth - containerWidth / 2;
      targetPositionClippy.y = Math.random() * containerHeight - containerHeight / 2;
    }

    function moveChickenStep() {
      const chickenNode = network.body.nodes[chickenNodeId];
      const clippyNode = network.body.nodes[clippyNodeId];

      if (!isDraggingChicken) {
        // Apply momentum to chicken
        chickenNode.x += chickenVelocity.x;
        chickenNode.y += chickenVelocity.y;

        // Dampen the velocity
        chickenVelocity.x *= 0.95;
        chickenVelocity.y *= 0.95;

        // If the velocity is very low, move the chicken back to the center
        if (Math.abs(chickenVelocity.x) < 0.1 && Math.abs(chickenVelocity.y) < 0.1) {
          const centerX = 0;
          const centerY = 0;
          const deltaX = centerX - chickenNode.x;
          const deltaY = centerY - chickenNode.y;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          if (distance < chickenSpeed) {
            chickenNode.x = centerX;
            chickenNode.y = centerY;
            chickenVelocity = { x: 0, y: 0 }; // Reset velocity
            setTimeout(setRandomTargetPosition, 1); // Set a new target position after 1ms
          } else {
            chickenNode.x += (deltaX / distance) * chickenSpeed;
            chickenNode.y += (deltaY / distance) * chickenSpeed;
          }
        }
      }

      if (!isDraggingClippy) {
        // Apply momentum to clippy
        clippyNode.x += clippyVelocity.x;
        clippyNode.y += clippyVelocity.y;

        // Dampen the velocity
        clippyVelocity.x *= 0.95;
        clippyVelocity.y *= 0.95;

        // If the velocity is very low, move the clippy back to the center
        if (Math.abs(clippyVelocity.x) < 0.1 && Math.abs(clippyVelocity.y) < 0.1) {
          const centerX = 0;
          const centerY = 0;
          const deltaX = centerX - clippyNode.x;
          const deltaY = centerY - clippyNode.y;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          if (distance < clippySpeed) {
            clippyNode.x = centerX;
            clippyNode.y = centerY;
            clippyVelocity = { x: 0, y: 0 }; // Reset velocity
            setTimeout(setRandomTargetPosition, 1); // Set a new target position after 1ms
          } else {
            clippyNode.x += (deltaX / distance) * clippySpeed;
            clippyNode.y += (deltaY / distance) * clippySpeed;
          }
        }
      }

      // Check for collisions with nodes and move around them
      const nodeIds = network.body.data.nodes.getIds();
      nodeIds.forEach((nodeId) => {
        if (nodeId !== chickenNodeId) {
          const nodePosition = network.getPositions([nodeId])[nodeId];
          const nodeDeltaX = nodePosition.x - chickenNode.x;
          const nodeDeltaY = nodePosition.y - chickenNode.y;
          const nodeDistance = Math.sqrt(nodeDeltaX * nodeDeltaX + nodeDeltaY * nodeDeltaY);

          if (nodeDistance < 100) { // If the chicken is near the node
            // Set a new target position to move around the node
            targetPositionChicken.x = chickenNode.x - nodeDeltaX;
            targetPositionChicken.y = chickenNode.y - nodeDeltaY;
          }
        }

        if (nodeId !== clippyNodeId) {
          const nodePosition = network.getPositions([nodeId])[nodeId];
          const nodeDeltaX = nodePosition.x - clippyNode.x;
          const nodeDeltaY = nodePosition.y - clippyNode.y;
          const nodeDistance = Math.sqrt(nodeDeltaX * nodeDeltaX + nodeDeltaY * nodeDeltaY);

          if (nodeDistance < 100) { // If the clippy is near the node
            // Set a new target position to move around the node
            targetPositionClippy.x = clippyNode.x - nodeDeltaX;
            targetPositionClippy.y = clippyNode.y - nodeDeltaY;
          }
        }
      });

      network.redraw();
    }

    function randomizeSpeeds() {
      chickenSpeed = Math.random() < 0.1 ? 15 : 5; // 10% chance to increase speed
      clippySpeed = Math.random() < 0.1 ? 15 : 5; // 10% chance to increase speed
    }

    async function init() {
      const devices = await getNetworkData();
      drawNetwork(devices);

      // Set an initial random target position
      setRandomTargetPosition();

      // Move chicken and clippy in small steps towards the target position
      setInterval(moveChickenStep, 1); // Move in small steps every 100ms

      // Randomize speeds every 2 seconds
      setInterval(randomizeSpeeds, 2000);
    }

    init();
  </script>
</body>
</html>