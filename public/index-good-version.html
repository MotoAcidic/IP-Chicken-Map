<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Diagram with Chicken and Eggs</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    /* Make the body fill the screen */
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Container for the network and the images */
    #container {
      width: 100vw; /* Full width of the screen */
      height: 100vh; /* Full height of the screen */
      position: relative; /* Container for the map and images */
      overflow: hidden;
      border: 1px solid #ccc; /* Optional border to visualize the container */
    }

    /* Network should fill the container */
    #network {
      width: 100%; /* Full width of the container */
      height: 100%; /* Full height of the container */
      position: absolute;
    }

    /* Button to clear all eggs */
    #clearEggsButton {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 2000; /* On top of everything */
      padding: 10px 20px;
      font-size: 16px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Network Map -->
    <div id="network"></div>

    <!-- Button to clear all eggs -->
    <button id="clearEggsButton">Clear Eggs</button>
  </div>

  <script>
    let network;
    let chickenNodeId = 'chicken';
    let targetPositionChicken = { x: 0, y: 0 };
    const screenPadding = 50; // Padding to prevent off-screen dragging
    let nodes = [];
    let edges = [];
    let chickenSpeed = 5; // Default chicken speed
    let chickenVelocity = { x: 0, y: 0 }; // Chicken velocity
    let isDraggingChicken = false;
    let lastMousePosition = { x: 0, y: 0 };

    async function getNetworkData() {
      const response = await fetch('/scan'); // Ensure your API is providing data
      return await response.json();
    }

    function inferConnections(devices) {
      const edges = [];
      for (let i = 0; i < devices.length - 1; i++) {
        const currentIp = devices[i].ip.split('.').map(Number);
        const nextIp = devices[i + 1].ip.split('.').map(Number);

        if (currentIp.slice(0, 3).join('.') === nextIp.slice(0, 3).join('.') && currentIp[3] + 1 === nextIp[3]) {
          edges.push({ from: i, to: i + 1 });
        }
      }
      return edges;
    }

    function drawNetwork(devices) {
      const container = document.getElementById('network');
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;

      nodes = devices.map((device, index) => ({
        id: index,
        label: `${device.name || 'Unknown'} (${device.ip})`,
        x: Math.random() * containerWidth - containerWidth / 2, // Random initial position
        y: Math.random() * containerHeight - containerHeight / 2 // Random initial position
      }));

      // Add the chicken as a node
      nodes.push({
        id: chickenNodeId,
        shape: 'image',
        image: 'chicken.png',
        size: 50,
        x: 0,
        y: 0
      });

      edges = inferConnections(devices);

      const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

      const options = {
        physics: {
          enabled: true,  // Enable physics to allow nodes to push each other around
          stabilization: { iterations: 150 } // More iterations to stabilize the network
        },
        interaction: {
          dragNodes: true,  // Allow dragging of nodes
          zoomView: true,   // Allow zooming
          dragView: true,   // Allow dragging of the view
        },
        layout: {
          improvedLayout: true,
        }
      };

      network = new vis.Network(container, data, options);

      // Set min and max zoom levels to allow zooming out
      network.on("zoom", function (params) {
        if (params.scale > 1.5) {
          network.moveTo({ scale: 1.5 }); // Max zoom in
        } else if (params.scale < 0.3) { // Allow more zoom out
          network.moveTo({ scale: 0.3 });
        }
      });

      // Add event listeners for dragging the chicken
      network.on("dragStart", function (params) {
        if (params.nodes.includes(chickenNodeId)) {
          isDraggingChicken = true;
          lastMousePosition = { x: params.event.center.x, y: params.event.center.y };
        }
      });

      network.on("dragging", function (params) {
        if (isDraggingChicken) {
          const currentMousePosition = { x: params.event.center.x, y: params.event.center.y };
          chickenVelocity.x = currentMousePosition.x - lastMousePosition.x;
          chickenVelocity.y = currentMousePosition.y - lastMousePosition.y;
          lastMousePosition = currentMousePosition;
        }
      });

      network.on("dragEnd", function (params) {
        if (isDraggingChicken) {
          isDraggingChicken = false;
        }
      });

      // Add event listener for mouse clicks to move the chicken
      container.addEventListener('click', (event) => {
        const rect = container.getBoundingClientRect();
        targetPositionChicken.x = event.clientX - rect.left - containerWidth / 2;
        targetPositionChicken.y = event.clientY - rect.top - containerHeight / 2;
      });
    }

    function setRandomTargetPosition() {
      const container = document.getElementById('container');
      const containerWidth = container.offsetWidth - screenPadding;
      const containerHeight = container.offsetHeight - screenPadding;

      targetPositionChicken.x = Math.random() * containerWidth - containerWidth / 2;
      targetPositionChicken.y = Math.random() * containerHeight - containerHeight / 2;
    }

    function dropEgg(x, y) {
      const eggNodeId = `egg_${Date.now()}`;
      nodes.push({
        id: eggNodeId,
        shape: 'image',
        image: 'egg.png',
        size: 30,
        x: x,
        y: y
      });
      network.body.data.nodes.add(nodes[nodes.length - 1]);
    }

    function clearEggs() {
      const eggNodes = nodes.filter(node => node.id.startsWith('egg_'));
      eggNodes.forEach(eggNode => {
        network.body.data.nodes.remove(eggNode.id);
      });
      nodes = nodes.filter(node => !node.id.startsWith('egg_'));
    }

    function moveChickenStep() {
      const chickenNode = network.body.nodes[chickenNodeId];

      if (!isDraggingChicken) {
        // Apply momentum to chicken
        chickenNode.x += chickenVelocity.x;
        chickenNode.y += chickenVelocity.y;

        // Dampen the velocity
        chickenVelocity.x *= 2;
        chickenVelocity.y *= 2;

        // If the velocity is very low, move the chicken towards the target position
        if (Math.abs(chickenVelocity.x) < 0.1 && Math.abs(chickenVelocity.y) < 0.1) {
          const deltaX = targetPositionChicken.x - chickenNode.x;
          const deltaY = targetPositionChicken.y - chickenNode.y;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          if (distance < chickenSpeed) {
            chickenNode.x = targetPositionChicken.x;
            chickenNode.y = targetPositionChicken.y;
            chickenVelocity = { x: 0, y: 0 }; // Reset velocity
            setTimeout(setRandomTargetPosition, 1); // Set a new target position after 1ms
          } else {
            chickenNode.x += (deltaX / distance) * chickenSpeed;
            chickenNode.y += (deltaY / distance) * chickenSpeed;
          }
        }

        // Randomly drop an egg
        if (Math.random() < 0.01) { // 1% chance to drop an egg each step
          dropEgg(chickenNode.x, chickenNode.y);
        }
      }

      // Check for collisions with nodes and move around them
      const nodeIds = network.body.data.nodes.getIds();
      nodeIds.forEach((nodeId) => {
        if (nodeId !== chickenNodeId) {
          const nodePosition = network.getPositions([nodeId])[nodeId];
          const nodeDeltaX = nodePosition.x - chickenNode.x;
          const nodeDeltaY = nodePosition.y - chickenNode.y;
          const nodeDistance = Math.sqrt(nodeDeltaX * nodeDeltaX + nodeDeltaY * nodeDeltaY);

          if (nodeDistance < 10) { // If the chicken is near the node
            // Set a new target position to move around the node
            targetPositionChicken.x = chickenNode.x - nodeDeltaX;
            targetPositionChicken.y = chickenNode.y - nodeDeltaY;
          }
        }
      });

      network.redraw();
    }

    function randomizeSpeeds() {
      chickenSpeed = Math.random() < 10 ? 15 : 5; // 10% chance to increase speed
    }

    async function init() {
      const devices = await getNetworkData();
      drawNetwork(devices);

      // Set an initial random target position
      setRandomTargetPosition();

      // Move chicken in small steps towards the target position
      setInterval(moveChickenStep, 1); // Move in small steps every 100ms

      // Randomize speeds every 2 seconds
      setInterval(randomizeSpeeds, 2000);

      // Add event listener to clear eggs button
      document.getElementById('clearEggsButton').addEventListener('click', clearEggs);
    }

    init();
  </script>
</body>
</html>